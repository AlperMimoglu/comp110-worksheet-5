comp110-worksheet-5
===================

>   by Alper Mimoglu

>   Questions

1.  This algorithm performs the task of finding a number in a list and when it
    finds the number it performs a check if the correct number is true. If not,
    it would keep looping the entire list until it finds the correct number.

2.  It is the worst because it gives the computer a higher load, the algorithm
    has a quadratic complexity because of the nested for loops. Each operation
    performed under the loop take n time by having a operation under a nested
    loop it takes n\*n time or n\^2 time.

3.  The algorithm is still correct because it does the same process as the
    original algorithm, but it is more efficient in the way itâ€™s being done.

4.  The algorithm will run faster because it has less checks to do. The
    algorithm will run approximately twice as fast because it has approximately
    less check to do.

5.  This algorithm still has a quadratic complexity because it still equal to
    n\^2 as 1/2n\^2 has the same big O notation as n\^2.

6.  O(nlogn) reference:
    https://www.quora.com/What-is-the-time-complexity-of-the-Python-built-in-sorted-function

7.  n\*O(1)= O(n) I think this is correct because this algorithm is using a
    liner time and it would always equal to O(n).

8.  The algorithm I think would run faster is the second one because if the
    second one has the big O notation of O(n) it would run more efficient than
    the first one which has the notation of O(n\^2) based on the Big O chart the
    first algorithm would be bad during operation than the second algorithm
    which has a rating of fair on the big O chart.

9.  The slower algorithm is more reliable because it is more accurate with the
    answers it gives because it verifies if it has the correct outcome if not it
    would loop until it gives the accurate answer.
